

<!doctype html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>nmrespy.nlp.nlp &#8212; NMR-EsPy  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/bizstyle.css" />
    
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">NMR-EsPy  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">nmrespy.nlp.nlp</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for nmrespy.nlp.nlp</h1><div class="highlight"><pre>
<span></span><span class="c1"># nlp.nlp.py</span>
<span class="c1"># Simon Hulse</span>
<span class="c1"># simon.hulse@chem.ox.ac.uk</span>

<span class="sd">&quot;&quot;&quot;Nonlinear programming for generating NMR parameter estiamtes&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">operator</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="k">as</span> <span class="nn">nlinalg</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span> <span class="k">as</span> <span class="nn">optimize</span>

<span class="kn">from</span> <span class="nn">nmrespy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">nmrespy._cols</span> <span class="k">as</span> <span class="nn">cols</span>
<span class="k">if</span> <span class="n">cols</span><span class="o">.</span><span class="n">USE_COLORAMA</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">colorama</span>
    <span class="n">colorama</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="kn">from</span> <span class="nn">nmrespy._errors</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">nmrespy._misc</span> <span class="kn">import</span> <span class="n">start_end_wrapper</span><span class="p">,</span> <span class="n">ArgumentChecker</span><span class="p">,</span> \
    <span class="n">FrequencyConverter</span>
<span class="kn">from</span> <span class="nn">nmrespy._timing</span> <span class="kn">import</span> <span class="n">timer</span>
<span class="kn">import</span> <span class="nn">nmrespy.nlp._funcs</span> <span class="k">as</span> <span class="nn">funcs</span>
<span class="kn">from</span> <span class="nn">nmrespy.sig</span> <span class="kn">import</span> <span class="n">get_timepoints</span>

<span class="c1"># TODO in a later version</span>
<span class="c1"># Add support for mode</span>
<span class="c1"># Was getting indexing errors inside _check_negative_amps</span>
<span class="c1"># when testing using a mode which is &#39;apfd&#39;</span>
<span class="c1">#</span>
<span class="c1"># For docs:</span>
<span class="c1">#</span>
<span class="c1"># mode : str, default: &#39;apfd&#39;</span>
<span class="c1">#     String composed of any combination of characters `&#39;a&#39;`, `&#39;p&#39;`, `&#39;f&#39;`,</span>
<span class="c1">#     `&#39;d&#39;`. Used to determine which parameter types to optimise, and which</span>
<span class="c1">#     to remain fixed:</span>
<span class="c1">#</span>
<span class="c1">#     * `&#39;a&#39;`: Amplitudes are optimised</span>
<span class="c1">#     * `&#39;p&#39;`: Phases are optimised</span>
<span class="c1">#     * `&#39;f&#39;`: Frequencies are optimised</span>
<span class="c1">#     * `&#39;d&#39;`: Damping factors are optimised</span>


<div class="viewcode-block" id="NonlinearProgramming"><a class="viewcode-back" href="../../../references/nlp/nlp.html#nmrespy.nlp.nlp.NonlinearProgramming">[docs]</a><span class="k">class</span> <span class="nc">NonlinearProgramming</span><span class="p">(</span><span class="n">FrequencyConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for nonlinear programming for determination of spectral parameter</span>
<span class="sd">    estimates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : numpy.ndarray</span>
<span class="sd">        Signal to be considered (unnormalised).</span>

<span class="sd">    theta0 : numpy.ndarray</span>
<span class="sd">        Initial parameter guess in the following form:</span>

<span class="sd">        * **1-dimensional data:**</span>

<span class="sd">          .. code-block::</span>

<span class="sd">             theta0 = numpy.array([</span>
<span class="sd">                 [a_1, φ_1, f_1, η_1],</span>
<span class="sd">                 [a_2, φ_2, f_2, η_2],</span>
<span class="sd">                 ...,</span>
<span class="sd">                 [a_m, φ_m, f_m, η_m],</span>
<span class="sd">             ])</span>

<span class="sd">        * **2-dimensional data:**</span>

<span class="sd">          .. code-block::</span>

<span class="sd">             theta0 = numpy.array([</span>
<span class="sd">                 [a_1, φ_1, f1_1, f2_1, η1_1, η2_1],</span>
<span class="sd">                 [a_2, φ_2, f1_2, f2_2, η1_2, η2_2],</span>
<span class="sd">                 ...,</span>
<span class="sd">                 [a_m, φ_m, f1_m, f2_m, η1_m, η2_m],</span>
<span class="sd">             ])</span>

<span class="sd">    sw : [float] or [float, float]</span>
<span class="sd">        The experiment sweep width in each dimension in Hz.</span>

<span class="sd">    offset : [float] or [float, float] or None, default: None</span>
<span class="sd">        The experiment transmitter offset frequency in Hz. If `None`,</span>
<span class="sd">        `offset` will be set as ``data.ndim * [0.0]``.</span>

<span class="sd">    sfo : [float], [float, float] or None, default: None</span>
<span class="sd">        The experiment transmitter frequency in each dimension in MHz.</span>
<span class="sd">        This is not necessary, however if it set it to `None`, no conversion</span>
<span class="sd">        of frequencies from Hz to ppm will be possible!</span>

<span class="sd">    start_point : int, default: 0</span>
<span class="sd">        The first timepoint sampled, in units of</span>
<span class="sd">        :math:`\\Delta t = 1 / f_{\\mathrm{sw}}`</span>

<span class="sd">    phase_variance : bool, default: True</span>
<span class="sd">        Specifies whether or not to include the variance of oscillator</span>
<span class="sd">        phases into the NLP routine. The fiedlity (cost function) is</span>
<span class="sd">        given by:</span>

<span class="sd">        * `phase_variance` set to `False`:</span>

<span class="sd">          .. math::</span>

<span class="sd">             \\mathcal{F}\\left(\\boldsymbol{\\theta}\\right) =</span>
<span class="sd">             \\left\\lVert \\boldsymbol{Y} - \\boldsymbol{X} \\right\\rVert_2^2</span>

<span class="sd">        * `phase_variance` set to `True`:</span>

<span class="sd">          .. math::</span>

<span class="sd">             \\mathcal{F}\\left(\\boldsymbol{\\theta}\\right) =</span>
<span class="sd">             \\left\\lVert \\boldsymbol{Y} - \\boldsymbol{X} \\right</span>
<span class="sd">             \\rVert_2^2 + \\mathrm{Var}\\left(\\boldsymbol{\\phi}\\right)</span>

<span class="sd">    method : &#39;trust_region&#39; or &#39;lbfgs&#39;, default: &#39;trust_region&#39;</span>
<span class="sd">        Optimisation algorithm to use. These utilise</span>
<span class="sd">        `scipy.optimise.minimise &lt;https://docs.scipy.org/doc/scipy/\</span>
<span class="sd">        reference/generated/scipy.optimize.minimize.html&gt;`_, with</span>
<span class="sd">        the method either being `trust-constr &lt;https://docs.scipy.org/doc/\</span>
<span class="sd">        scipy/reference/optimize.minimize-trustconstr.html\</span>
<span class="sd">        #optimize-minimize-trustconstr&gt;`_, or</span>
<span class="sd">        `L-BFGS-B &lt;https://docs.scipy.org/doc/scipy/reference/\</span>
<span class="sd">        optimize.minimize-lbfgsb.html#optimize-minimize-lbfgsb&gt;`_.</span>

<span class="sd">    bound : bool, default: False</span>
<span class="sd">        Specifies whether or not to bound the parameters during optimisation.</span>
<span class="sd">        Bounds are given by:</span>

<span class="sd">        * :math:`0 \\leq a_m \\leq \\infty`</span>
<span class="sd">        * :math:`-\\pi &lt; \\phi_m \\leq \\pi`</span>
<span class="sd">        * :math:`-f_{\\mathrm{sw}} / 2 + f_{\\mathrm{off}} \\leq f_m \\leq\</span>
<span class="sd">        f_{\\mathrm{sw}} / 2 + f_{\\mathrm{off}}`</span>
<span class="sd">        * :math:`0 \\leq \\eta_m \\leq \\infty`</span>

<span class="sd">        :math:`(\\forall m \\in \\{1, \\cdots, M\\})`</span>

<span class="sd">    max_iterations : int or None, default: None</span>
<span class="sd">        A value specifiying the number of iterations the routine may run</span>
<span class="sd">        through before it is terminated. If `None`, the default number</span>
<span class="sd">        of maximum iterations is set (`100` if `method` is `&#39;trust_region&#39;`,</span>
<span class="sd">        and `500` if `method` is `&#39;lbfgs&#39;`).</span>

<span class="sd">    amp_thold : float or None, default: None</span>
<span class="sd">        A value that imposes a threshold for deleting oscillators of</span>
<span class="sd">        negligible ampltiude. If `None`, does nothing. If a float, oscillators</span>
<span class="sd">        with amplitudes satisfying :math:`a_m &lt; a_{\\mathrm{thold}}</span>
<span class="sd">        \\lVert \\boldsymbol{a} \\rVert_2`` will be removed from the</span>
<span class="sd">        parameter array, where :math:`\\lVert \\boldsymbol{a} \\rVert_2`</span>
<span class="sd">        is the Euclidian norm of the vector of all the oscillator amplitudes.</span>
<span class="sd">        It is advised to set `amp_thold` at least a couple of orders of</span>
<span class="sd">        magnitude below 1.</span>

<span class="sd">    freq_thold : float or None</span>
<span class="sd">        If `None`, does nothing. If a float, oscillator pairs with</span>
<span class="sd">        frequencies satisfying</span>
<span class="sd">        :math:`\\lvert f_m - f_p \\rvert &lt; f_{\\mathrm{thold}}` will be</span>
<span class="sd">        removed from the parameter array. A new oscillator will be included</span>
<span class="sd">        in the array, with parameters:</span>

<span class="sd">        * amplitude: :math:`a = a_m + a_p`</span>
<span class="sd">        * phase: :math:`\\phi = \\left(\\phi_m + \\phi_p\\right) / 2`</span>
<span class="sd">        * frequency: :math:`f = \\left(f_m + f_p\\right) / 2`</span>
<span class="sd">        * damping: :math:`\\eta = \\left(\\eta_m + \\eta_p\\right) / 2`</span>

<span class="sd">        .. warning::</span>

<span class="sd">           NOT IMPLEMENTED YET</span>

<span class="sd">    negative_amps : &#39;remove&#39; or &#39;flip_phase&#39;, default: &#39;remove&#39;</span>
<span class="sd">        Indicates how to treat oscillators which have gained negative</span>
<span class="sd">        amplitudes during the optimisation.</span>

<span class="sd">        * `&#39;remove&#39;` will result in such oscillators being purged from</span>
<span class="sd">          the parameter estimate. The optimisation routine will the be</span>
<span class="sd">          re-run recursively until no oscillators have a negative amplitude.</span>
<span class="sd">        * `&#39;flip_phase&#39;` will retain oscillators with negative amplitudes,</span>
<span class="sd">          but the the amplitudes will be multiplied by -1, and a π radians</span>
<span class="sd">          phase shift will be applied to these oscillators.</span>

<span class="sd">    fprint : bool, default: True</span>
<span class="sd">        If `True`, the method provides information on progress to</span>
<span class="sd">        the terminal as it runs. If `False`, the method will run silently.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The two optimisation algorithms (specified by `method`) primarily</span>
<span class="sd">    differ in how they treat the calculation of the matrix of cost</span>
<span class="sd">    function second derivatives (called the Hessian). `&#39;trust_region&#39;`</span>
<span class="sd">    will calculate the Hessian explicitly at every iteration, whilst</span>
<span class="sd">    `&#39;lbfgs&#39;` uses an update formula based on gradient information to</span>
<span class="sd">    estimate the Hessian. The upshot of this is that the convergence</span>
<span class="sd">    rate (the number of iterations needed to reach convergence) is</span>
<span class="sd">    typically better for `&#39;trust_region&#39;`, though each iteration</span>
<span class="sd">    typically takes longer to generate. By default, it is advised to</span>
<span class="sd">    use `&#39;trust_region&#39;`, however if your guess has a large number</span>
<span class="sd">    of signals, you may find `&#39;lbfgs&#39;` performs more effectively.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">start_txt</span> <span class="o">=</span> <span class="s1">&#39;NONLINEAR PROGRAMMING STARTED&#39;</span>
    <span class="n">end_txt</span> <span class="o">=</span> <span class="s1">&#39;NONLINEAR PROGRAMMING COMPLETE&#39;</span>

<div class="viewcode-block" id="NonlinearProgramming.__init__"><a class="viewcode-back" href="../../../references/nlp/nlp.html#nmrespy.nlp.nlp.NonlinearProgramming.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">theta0</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">sfo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start_point</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">phase_variance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;trust_region&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">max_iterations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">amp_thold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq_thold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">negative_amps</span><span class="o">=</span><span class="s1">&#39;remove&#39;</span><span class="p">,</span> <span class="n">fprint</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;apfd&#39;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialise the class instance. Checks that all arguments are</span>
<span class="sd">        valid&quot;&quot;&quot;</span>

        <span class="c1"># --- Check validity of parameters -------------------------------</span>
        <span class="c1"># Data should be a NumPy array.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">R</span><span class="si">}</span><span class="s1">data should be a numpy ndarray</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">END</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

        <span class="c1"># Determine data dimension. If greater than 2, return error.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MoreThanTwoDimError</span><span class="p">()</span>

        <span class="c1"># Number of &quot;types&quot; or parameters.</span>
        <span class="c1"># This will be 4 if the signal is 1D, and 6 if 2D.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">2</span>

        <span class="c1"># If offset is None, set it to zero in each dimension</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span>

        <span class="k">if</span> <span class="n">max_iterations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_iterations</span> <span class="o">=</span> <span class="mi">100</span>

        <span class="c1"># Determine validity of other args using ArgumentChecker</span>
        <span class="n">components</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">theta0</span><span class="p">,</span> <span class="s1">&#39;theta0&#39;</span><span class="p">,</span> <span class="s1">&#39;parameter&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="n">sw</span><span class="p">,</span> <span class="s1">&#39;sw&#39;</span><span class="p">,</span> <span class="s1">&#39;float_list&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span><span class="p">,</span> <span class="s1">&#39;float_list&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="n">start_point</span><span class="p">,</span> <span class="s1">&#39;start_point&#39;</span><span class="p">,</span> <span class="s1">&#39;positive_int_or_zero&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="n">phase_variance</span><span class="p">,</span> <span class="s1">&#39;phase_variance&#39;</span><span class="p">,</span> <span class="s1">&#39;bool&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="n">max_iterations</span><span class="p">,</span> <span class="s1">&#39;max_iterations&#39;</span><span class="p">,</span> <span class="s1">&#39;positive_int&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="s1">&#39;optimiser_mode&#39;</span><span class="p">),</span>  <span class="c1"># TODO</span>
            <span class="p">(</span><span class="n">negative_amps</span><span class="p">,</span> <span class="s1">&#39;negative_amps&#39;</span><span class="p">,</span> <span class="s1">&#39;negative_amplidue&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="n">fprint</span><span class="p">,</span> <span class="s1">&#39;fprint&#39;</span><span class="p">,</span> <span class="s1">&#39;bool&#39;</span><span class="p">),</span>
        <span class="p">]</span>

        <span class="c1"># Certain arguments should be checked only if they are not None...</span>
        <span class="k">if</span> <span class="n">sfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">components</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sfo</span><span class="p">,</span> <span class="s1">&#39;sfo&#39;</span><span class="p">,</span> <span class="s1">&#39;float_list&#39;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">amp_thold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">components</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">amp_thold</span><span class="p">,</span> <span class="s1">&#39;amp_thold&#39;</span><span class="p">,</span> <span class="s1">&#39;zero_to_one&#39;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">freq_thold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">components</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">freq_thold</span><span class="p">,</span> <span class="s1">&#39;freq_thold&#39;</span><span class="p">,</span> <span class="s1">&#39;positive_float&#39;</span><span class="p">))</span>

        <span class="c1"># Check arguments are valid!</span>
        <span class="n">ArgumentChecker</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>

        <span class="c1"># TODO</span>
        <span class="c1"># # Gets upset when phase variance is switched on, but phases</span>
        <span class="c1"># # are not to be optimised (the user is being unclear about</span>
        <span class="c1"># # their purpose)</span>
        <span class="c1"># if phase_variance and &#39;p&#39; not in mode:</span>
        <span class="c1">#     raise PhaseVarianceAmbiguityError(mode)</span>

        <span class="c1"># --- Create attributes ------------------------------------------</span>
        <span class="c1"># Reshape parameter array to vector:</span>
        <span class="c1"># (M, 4) -&gt; (4*M,) or (M, 6) -&gt; (6*M,)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta0</span> <span class="o">=</span> <span class="n">theta0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sw</span> <span class="o">=</span> <span class="n">sw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sfo</span> <span class="o">=</span> <span class="n">sfo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_point</span> <span class="o">=</span> <span class="n">start_point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase_variance</span> <span class="o">=</span> <span class="n">phase_variance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>  <span class="c1"># TODO</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bound</span> <span class="o">=</span> <span class="n">bound</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span> <span class="o">=</span> <span class="n">max_iterations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">amp_thold</span> <span class="o">=</span> <span class="n">amp_thold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freq_thold</span> <span class="o">=</span> <span class="n">freq_thold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">negative_amps</span> <span class="o">=</span> <span class="n">negative_amps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fprint</span> <span class="o">=</span> <span class="n">fprint</span>

        <span class="c1"># Number of oscillators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta0</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
        <span class="c1"># Number of points in each dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If sfo was given an explicit value, create a frequency</span>
            <span class="c1"># converter, enabling outputs in ppm.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">converter</span> <span class="o">=</span> <span class="n">FrequencyConverter</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfo</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If max_iterations is set to None, set it to default value</span>
            <span class="c1"># If &#39;trust_region&#39;, set as 100. Need to explicitely compute</span>
            <span class="c1"># the Hessian for this alg., so each iteration is typically</span>
            <span class="c1"># quite costly. L-BFGS is typically quicker per iteration, so</span>
            <span class="c1"># give it more.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span> <span class="o">=</span> <span class="mi">100</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;trust_region&#39;</span> <span class="k">else</span> <span class="mi">500</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">amp_thold</span> <span class="o">=</span> <span class="mf">0.</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_thold</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_thold</span>
        <span class="c1"># TODO freq-thold?</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_run_nlp</span><span class="p">()</span></div>

<div class="viewcode-block" id="NonlinearProgramming._run_nlp"><a class="viewcode-back" href="../../../references/nlp/nlp.html#nmrespy.nlp.nlp.NonlinearProgramming._run_nlp">[docs]</a>    <span class="nd">@timer</span>
    <span class="nd">@start_end_wrapper</span><span class="p">(</span><span class="n">start_txt</span><span class="p">,</span> <span class="n">end_txt</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_run_nlp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Runs nonlinear programming&quot;&quot;&quot;</span>

        <span class="c1"># Normalise data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">nlinalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normed_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span>

        <span class="c1"># Vectorise the initial parameter array</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta0</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="c1"># Perform some tweaks to regularise x0:</span>
        <span class="c1"># 1. Divide amplitudes by the norm of the data</span>
        <span class="n">x0</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span>
        <span class="c1"># 2. Shift oscillator frequencies to center about 0</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shift_offset</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="s1">&#39;center&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sw</span><span class="p">)</span>
        <span class="c1"># Time points in each dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tp</span> <span class="o">=</span> <span class="n">get_timepoints</span><span class="p">(</span>
            <span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_point</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sw</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tp</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start_point</span><span class="p">:]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tp</span><span class="p">]</span>

        <span class="c1"># Determine &#39;active&#39; and &#39;passive&#39; parameters based on self.mode</span>
        <span class="c1"># generates self.active_idx and self.passive_idx</span>
        <span class="c1">#</span>
        <span class="c1"># If one wanted to just optimise amplitudes and</span>
        <span class="c1"># frequencies, self.active_idx would be [0, 2], and therefore</span>
        <span class="c1"># self.passive_idx would be [1, 3]:</span>
        <span class="c1"># a1  ...  am  φ1  ...  φm  f1  ...  fm  η1  ...  ηm</span>
        <span class="c1"># &lt; idx = 0 &gt;  &lt; idx = 1 &gt;  &lt; idx = 2 &gt;  &lt; idx = 3 &gt;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_active_passive_indices</span><span class="p">()</span>

        <span class="c1"># Takes the scaled parameter vector x0, with shape</span>
        <span class="c1"># (4 * self.m,) or (6 * self.m,), and splits up into vector of</span>
        <span class="c1"># active parameters and vector of passive parameters</span>
        <span class="c1"># called self.active and self.passive</span>
        <span class="c1">#</span>
        <span class="c1"># Active parameters: parameters that are going to actually be</span>
        <span class="c1"># optimised</span>
        <span class="c1">#</span>
        <span class="c1"># Passive parameters: parameters that are to be fixed at their</span>
        <span class="c1"># original value. These are still required however, in order</span>
        <span class="c1"># to compute the fiedlity, its grad and its Hessian.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_split_active_passive</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>

        <span class="c1"># Determine cost function, gradient, and hessian based on the data</span>
        <span class="c1"># dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;fidelity&#39;</span><span class="p">:</span> <span class="n">funcs</span><span class="o">.</span><span class="n">f_1d</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">funcs</span><span class="o">.</span><span class="n">f_2d</span><span class="p">,</span>
            <span class="s1">&#39;gradient&#39;</span><span class="p">:</span> <span class="n">funcs</span><span class="o">.</span><span class="n">g_1d</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">funcs</span><span class="o">.</span><span class="n">g_2d</span><span class="p">,</span>
            <span class="s1">&#39;hessian&#39;</span><span class="p">:</span> <span class="n">funcs</span><span class="o">.</span><span class="n">h_1d</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">funcs</span><span class="o">.</span><span class="n">h_2d</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># This method is called recursively until no negative amplitudes</span>
        <span class="c1"># are found within the parameter estimate.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recursive_optimise</span><span class="p">()</span>

        <span class="c1"># --- Finishing up -------------------------------------------</span>
        <span class="c1"># Merge self.active and self.passive to get the full vector</span>
        <span class="c1"># called self.result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_merge_active_passive</span><span class="p">()</span>
        <span class="c1"># Remove any oscillators with negligible amplitudes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_negligible_amplitudes</span><span class="p">()</span>

        <span class="c1"># Rescale and correct for offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shift_offset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;displace&#39;</span><span class="p">)</span>
        <span class="c1"># Get estimate errors (self.errors)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_errors</span><span class="p">()</span>

        <span class="c1"># Reshape result array back to (M x 4) or (M x 6)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="c1"># Order oscillators by frequency</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">[</span><span class="n">order</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_recursive_optimise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># Extra arguments (other than initial guess, which is self.active)</span>
        <span class="c1"># that are needed to compute the fidelity and its derivatives</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimiser_args</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">normed_data</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tp</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">passive</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">active_idx</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phase_variance</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Dermine bounds for optimiser. Could be None (unconstrained), or</span>
        <span class="c1"># bounds that are physically reasonable for the system being</span>
        <span class="c1"># considered</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_bounds</span><span class="p">()</span>

        <span class="c1"># Calls the desired optimisation routine, updating self.active</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_run_optimiser</span><span class="p">()</span>

        <span class="c1"># Dermine whether any negative amplitudes are in self.active</span>
        <span class="n">terminate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_negative_amps</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">terminate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_recursive_optimise</span><span class="p">()</span>

<div class="viewcode-block" id="NonlinearProgramming.get_result"><a class="viewcode-back" href="../../../references/nlp/nlp.html#nmrespy.nlp.nlp.NonlinearProgramming.get_result">[docs]</a>    <span class="k">def</span> <span class="nf">get_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq_unit</span><span class="o">=</span><span class="s1">&#39;hz&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Obtain the result of nonlinear programming.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq_unit : &#39;hz&#39; or &#39;ppm&#39;, default: &#39;hz&#39;</span>
<span class="sd">            The unit of the oscillator frequencies (corresponding to</span>
<span class="sd">            ``result[:, 2]``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_array</span><span class="p">(</span><span class="s1">&#39;result&#39;</span><span class="p">,</span> <span class="n">freq_unit</span><span class="p">)</span></div>

<div class="viewcode-block" id="NonlinearProgramming.get_errors"><a class="viewcode-back" href="../../../references/nlp/nlp.html#nmrespy.nlp.nlp.NonlinearProgramming.get_errors">[docs]</a>    <span class="k">def</span> <span class="nf">get_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq_unit</span><span class="o">=</span><span class="s1">&#39;hz&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Obtain errors of parameters estimates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq_unit : &#39;hz&#39; or &#39;ppm&#39;, default: &#39;hz&#39;</span>
<span class="sd">            The unit of the oscillator frequencies (corresponding to</span>
<span class="sd">            ``result[:, 2]``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_array</span><span class="p">(</span><span class="s1">&#39;errors&#39;</span><span class="p">,</span> <span class="n">freq_unit</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">freq_unit</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">freq_unit</span> <span class="o">==</span> <span class="s1">&#39;hz&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">freq_unit</span> <span class="o">==</span> <span class="s1">&#39;ppm&#39;</span><span class="p">:</span>
            <span class="c1"># Check whether a frequency converter is associated with the</span>
            <span class="c1"># class</span>
            <span class="k">if</span> <span class="s1">&#39;converter&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">R</span><span class="si">}</span><span class="s1">Insufficient information to determine&#39;</span>
                    <span class="sa">f</span><span class="s1">&#39; frequencies in ppm. Did you perhaps forget to specify&#39;</span>
                    <span class="sa">f</span><span class="s1">&#39; sfo?</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">END</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

            <span class="c1"># Get frequencies in Hz, and format to enable input into</span>
            <span class="c1"># the frequency converter.</span>
            <span class="c1"># Then convert values to ppm and reconvert back to NumPy array</span>
            <span class="n">ppm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span>
                    <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])],</span> <span class="n">conversion</span><span class="o">=</span><span class="s1">&#39;hz-&gt;ppm&#39;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">result</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ppm</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidUnitError</span><span class="p">(</span><span class="s1">&#39;hz&#39;</span><span class="p">,</span> <span class="s1">&#39;ppm&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="NonlinearProgramming._shift_offset"><a class="viewcode-back" href="../../../references/nlp/nlp.html#nmrespy.nlp.nlp.NonlinearProgramming._shift_offset">[docs]</a>    <span class="k">def</span> <span class="nf">_shift_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">direction</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shifts frequencies to centre to or displace from 0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : numpy.ndarray</span>
<span class="sd">            Full parameter array</span>

<span class="sd">        direction : &#39;center&#39; or &#39;displace&#39;</span>
<span class="sd">            `&#39;center&#39;` shifts frerquencies such that the central frequency</span>
<span class="sd">            is set to zero. `&#39;displace&#39;` moves frequencies away from zero,</span>
<span class="sd">            to be reflected by offset.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">off</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">):</span>
            <span class="c1"># Dimension (i+1)&#39;s frequency parameters are given by this slice</span>
            <span class="nb">slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_slice</span><span class="p">([</span><span class="mi">2</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
            <span class="c1"># Take frequencies from offset values to be centred at zero</span>
            <span class="c1"># i.e.</span>
            <span class="c1"># | 10 9 8 7 6 5 4 3 2 1 0 | -&gt; | 5 4 3 2 1 0 -1 -2 -3 -4 -5 |</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;center&#39;</span><span class="p">:</span>
                <span class="n">params</span><span class="p">[</span><span class="nb">slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="nb">slice</span><span class="p">]</span> <span class="o">-</span> <span class="n">off</span>
            <span class="c1"># Do the reverse of the above (take away from being centered at</span>
            <span class="c1"># zero)</span>
            <span class="c1"># i.e.</span>
            <span class="c1"># | 5 4 3 2 1 0 -1 -2 -3 -4 -5 | -&gt; | 10 9 8 7 6 5 4 3 2 1 0 |</span>
            <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;displace&#39;</span><span class="p">:</span>
                <span class="n">params</span><span class="p">[</span><span class="nb">slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="nb">slice</span><span class="p">]</span> <span class="o">+</span> <span class="n">off</span>

        <span class="k">return</span> <span class="n">params</span></div>

<div class="viewcode-block" id="NonlinearProgramming._get_slice"><a class="viewcode-back" href="../../../references/nlp/nlp.html#nmrespy.nlp.nlp.NonlinearProgramming._get_slice">[docs]</a>    <span class="k">def</span> <span class="nf">_get_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">osc_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        idx : list</span>
<span class="sd">            Parameter types to be targeted. Valid ints are `0` to `3`</span>
<span class="sd">            (included) for a 1D signal, and `0` to `5` for a 2D signal</span>

<span class="sd">        osc_idx : list or None default: None</span>
<span class="sd">            Oscillators to be targeted. Can be either `None`, where all</span>
<span class="sd">            oscillators are indexed, or a list of ints, in order to select</span>
<span class="sd">            a subset of oscillators. Valid ints are `0` to `self.m - 1`</span>
<span class="sd">            (included).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        slice : numpy.ndarray</span>
<span class="sd">            Array slice.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Array of osccilators to index</span>
        <span class="k">if</span> <span class="n">osc_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">osc_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">))</span>

        <span class="nb">slice</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
            <span class="c1"># Note that parameters are arranged as:</span>
            <span class="c1"># a1  ...  am  φ1  ...  φm  f1  ...  fm  η1  ...  ηm (1D case)</span>
            <span class="c1"># ∴ stride length of m to go to the next &quot;type&quot; of parameter</span>
            <span class="c1"># and stride length of 1 to go to the next oscillator.</span>
            <span class="nb">slice</span> <span class="o">+=</span> <span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">+</span> <span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">osc_idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="nb">slice</span><span class="p">]</span></div>

<div class="viewcode-block" id="NonlinearProgramming._get_active_passive_indices"><a class="viewcode-back" href="../../../references/nlp/nlp.html#nmrespy.nlp.nlp.NonlinearProgramming._get_active_passive_indices">[docs]</a>    <span class="k">def</span> <span class="nf">_get_active_passive_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine the indices of blocks of the parameter vector that</span>
<span class="sd">        contain the active and passive parameters&quot;&quot;&quot;</span>
        <span class="c1"># Recall, for the 1D case, the indices correspond to the following</span>
        <span class="c1"># blocks in the vector:</span>
        <span class="c1"># a1  ...  am  φ1  ...  φm  f1  ...  fm  η1  ...  ηm</span>
        <span class="c1"># &lt; idx = 0 &gt;  &lt; idx = 1 &gt;  &lt; idx = 2 &gt;  &lt; idx = 3 &gt;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span>  <span class="c1"># Amplitude</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">active_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span>  <span class="c1"># Phase</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">active_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>  <span class="c1"># Frequecy (add indices for each dim)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">active_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span>  <span class="c1"># Damping (add indices for each dim)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">active_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>

        <span class="c1"># Initialise passive index array as containing all valid values,</span>
        <span class="c1"># and remove all values that are found in active index array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">passive_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_idx</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">passive_idx</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></div>

<div class="viewcode-block" id="NonlinearProgramming._merge_active_passive"><a class="viewcode-back" href="../../../references/nlp/nlp.html#nmrespy.nlp.nlp.NonlinearProgramming._merge_active_passive">[docs]</a>    <span class="k">def</span> <span class="nf">_merge_active_passive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given the active and passive parameters in vector form, merge to</span>
<span class="sd">        form the complete parameter vector</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        active_vec : numpy.ndarray</span>
<span class="sd">            Active vector.</span>

<span class="sd">        passive_vec : numpy,ndarray</span>
<span class="sd">            Passive vector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        merged_vec : numpy.ndarray</span>
<span class="sd">            Merged (complete) vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Determine indices in merged_vec that will relate to passive</span>
            <span class="c1"># parameters</span>
            <span class="n">passive_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">passive_idx</span><span class="p">)</span>

        <span class="c1"># ValueError is raised if the are no passive parameters,</span>
        <span class="c1"># as an empty list is not iterable!</span>
        <span class="c1"># In this case, the active vector is equivalent to the full</span>
        <span class="c1"># vector, so just return it.</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span>

        <span class="c1"># Determine indices in merged_vec that will relate to active</span>
        <span class="c1"># parameters</span>
        <span class="n">active_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active_idx</span><span class="p">)</span>
        <span class="c1"># Construct the merged vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[</span><span class="n">active_slice</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[</span><span class="n">passive_slice</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">passive</span></div>

<div class="viewcode-block" id="NonlinearProgramming._split_active_passive"><a class="viewcode-back" href="../../../references/nlp/nlp.html#nmrespy.nlp.nlp.NonlinearProgramming._split_active_passive">[docs]</a>    <span class="k">def</span> <span class="nf">_split_active_passive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">merged_vec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a full vector of parameters, split to form vectors of active</span>
<span class="sd">        and passive parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        merged_vec : numpy.ndarray</span>
<span class="sd">            Full parameter vector</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        active_vec : numpy.ndarray</span>
<span class="sd">            Active vector.</span>

<span class="sd">        passive_vec : numpy,ndarray</span>
<span class="sd">            Passive vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine indices in the merged vector that correspond to</span>
        <span class="c1"># values for the passive vector</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">passive_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">passive_idx</span><span class="p">)</span>

        <span class="c1"># ValueError is raised if there are no passive parameters</span>
        <span class="c1"># simply return the full vector as the active vector, and an empty</span>
        <span class="c1"># vector as the passive vector</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">merged_vec</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="c1"># Determine indices in the merged vector that correspond to</span>
        <span class="c1"># values for the active vector</span>
        <span class="n">active_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active_idx</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">passive</span> <span class="o">=</span> \
            <span class="n">merged_vec</span><span class="p">[</span><span class="n">active_slice</span><span class="p">],</span> <span class="n">merged_vec</span><span class="p">[</span><span class="n">passive_slice</span><span class="p">]</span></div>

<div class="viewcode-block" id="NonlinearProgramming._get_bounds"><a class="viewcode-back" href="../../../references/nlp/nlp.html#nmrespy.nlp.nlp.NonlinearProgramming._get_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">_get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructs a list of bounding constraints to set for each</span>
<span class="sd">        parameter. The bounds are as follows:</span>

<span class="sd">        * amplitudes: 0 &lt; a &lt; ∞</span>
<span class="sd">        * phases: -π &lt; φ &lt; π</span>
<span class="sd">        * frequencies: offset - sw/2 &lt; f &lt; offset + sw/2</span>
<span class="sd">        * damping: 0 &lt; η &lt; ∞</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound</span><span class="p">:</span>
            <span class="c1"># Unconstrained optimisation selected</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Amplitude</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_idx</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">+=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span>
            <span class="c1"># Phase</span>
            <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_idx</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">+=</span> <span class="p">[(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span>
            <span class="c1"># Frequency (iterate over each dimension)</span>
            <span class="k">if</span> <span class="mi">2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_idx</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sw</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sw</span><span class="p">:</span>
                    <span class="c1"># N.B. as the frequencies are centred about zero</span>
                    <span class="c1"># the valid frequency range is:</span>
                    <span class="c1"># -sw / 2 -&gt; sw / 2</span>
                    <span class="c1"># NOT -sw / 2 + offset -&gt; sw / 2 + offset</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">+=</span> <span class="p">[(</span><span class="o">-</span><span class="n">sw</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sw</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span>
            <span class="c1"># Damping (iterate over each dimension)</span>
            <span class="c1"># 2 + self.dim = 3 for 1D and 4 for 2D</span>
            <span class="k">if</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_idx</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">+=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_run_optimiser</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fprint</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fprint</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="c1"># Trust-Region</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;trust_region&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
                <span class="n">fun</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;fidelity&#39;</span><span class="p">],</span>
                <span class="n">x0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optimiser_args</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s1">&#39;trust-constr&#39;</span><span class="p">,</span>
                <span class="n">jac</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;gradient&#39;</span><span class="p">],</span>
                <span class="n">hess</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;hessian&#39;</span><span class="p">],</span>
                <span class="n">bounds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span>
                <span class="n">options</span><span class="o">=</span><span class="p">{</span>
                    <span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">,</span>
                    <span class="s1">&#39;verbose&#39;</span><span class="p">:</span> <span class="n">fprint</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
        <span class="c1"># L-BFGS</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;lbfgs&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
                <span class="n">fun</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;fidelity&#39;</span><span class="p">],</span>
                <span class="n">x0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optimiser_args</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s1">&#39;L-BFGS-B&#39;</span><span class="p">,</span>
                <span class="n">jac</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;gradient&#39;</span><span class="p">],</span>
                <span class="n">bounds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span>
                <span class="n">options</span><span class="o">=</span><span class="p">{</span>
                    <span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span><span class="p">,</span>
                    <span class="s1">&#39;iprint&#39;</span><span class="p">:</span> <span class="n">fprint</span> <span class="o">//</span> <span class="mi">3</span><span class="p">,</span>
                    <span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span>
                <span class="p">}</span>
            <span class="p">)</span>

        <span class="c1"># Extract result from optimiser dictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="NonlinearProgramming._check_negative_amps"><a class="viewcode-back" href="../../../references/nlp/nlp.html#nmrespy.nlp.nlp.NonlinearProgramming._check_negative_amps">[docs]</a>    <span class="k">def</span> <span class="nf">_check_negative_amps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determines which oscillators (if any) have negative amplitudes, and</span>
<span class="sd">        removes them, or recasts them with positive amplitude and a 180° phase</span>
<span class="sd">        shift.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        term : bool</span>
<span class="sd">            Used by :py:meth:`_optimise` to decide whether to terminate</span>
<span class="sd">            or re-run the optimisation routine.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_idx</span><span class="p">:</span>
            <span class="c1"># Generates length-1 tuple (unpack)</span>
            <span class="n">negative_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Check if there are any negative amps by determining</span>
            <span class="c1"># if negative_idx is empty or not</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">negative_idx</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="c1"># Negative amplitudes exist... deal with these</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">negative_amps</span> <span class="o">==</span> <span class="s1">&#39;remove&#39;</span><span class="p">:</span>
                <span class="c1"># Remove oscillators with negative amplitudes</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_get_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active_idx</span><span class="p">,</span> <span class="n">osc_idx</span><span class="o">=</span><span class="n">negative_idx</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">passive</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">passive</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_get_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">passive_idx</span><span class="p">,</span> <span class="n">osc_idx</span><span class="o">=</span><span class="n">negative_idx</span><span class="p">),</span>
                <span class="p">)</span>

                <span class="c1"># Update the number of oscillators</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active_idx</span><span class="p">))</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fprint</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">OR</span><span class="si">}</span><span class="s1">Negative amplitudes detected. These&#39;</span>
                        <span class="sa">f</span><span class="s1">&#39; oscillators will be removed</span><span class="se">\n</span><span class="s1">&#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;Updated number of oscillators: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="si">}{</span><span class="n">cols</span><span class="o">.</span><span class="n">END</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="p">)</span>
                <span class="c1"># Returning False means the optimisiser will be re-run</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">negative_amps</span> <span class="o">==</span> <span class="s1">&#39;flip_phase&#39;</span><span class="p">:</span>
                <span class="c1"># Make negative amplitude oscillators positive and flip</span>
                <span class="c1"># phase by 180°</span>

                <span class="c1"># Amplitudes</span>
                <span class="n">amp_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_slice</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">osc_idx</span><span class="o">=</span><span class="n">negative_idx</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">[</span><span class="n">amp_slice</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

                <span class="c1"># Phase flip</span>
                <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">:</span>
                    <span class="n">phase_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_slice</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">osc_idx</span><span class="o">=</span><span class="n">negative_idx</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">[</span><span class="n">phase_slice</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">_pi_flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">[</span><span class="n">phase_slice</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">phase_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_slice</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">osc_idx</span><span class="o">=</span><span class="n">negative_idx</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">passive</span><span class="p">[</span><span class="n">phase_slice</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">_pi_flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">passive</span><span class="p">[</span><span class="n">phase_slice</span><span class="p">])</span>

        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="NonlinearProgramming._pi_flip"><a class="viewcode-back" href="../../../references/nlp/nlp.html#nmrespy.nlp.nlp.NonlinearProgramming._pi_flip">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_pi_flip</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;flip array of phases by π raidnas, ensuring the phases remain in</span>
<span class="sd">        the range (-π, π]&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">arr</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span></div>

<div class="viewcode-block" id="NonlinearProgramming._get_errors"><a class="viewcode-back" href="../../../references/nlp/nlp.html#nmrespy.nlp.nlp.NonlinearProgramming._get_errors">[docs]</a>    <span class="k">def</span> <span class="nf">_get_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine the errors of the estimation result&quot;&quot;&quot;</span>

        <span class="c1"># Set phase_variance to False</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optimiser_args</span><span class="p">))</span>
        <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># Compute fidelity and hessian for error</span>
        <span class="n">fidelity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;fidelity&#39;</span><span class="p">](</span><span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">[</span><span class="s1">&#39;hessian&#39;</span><span class="p">](</span><span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># See newton_meets_ockham, Eq. (22)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="n">fidelity</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">nlinalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">hessian</span><span class="p">)))</span> <span class="o">/</span>
            <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">])</span>
        <span class="p">)</span>

        <span class="c1"># Re-scale amplitude errors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="mi">4</span><span class="p">),</span> <span class="mi">4</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_negligible_amplitudes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># Threshold</span>
        <span class="n">thold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_thold</span> <span class="o">*</span> <span class="n">nlinalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">])</span>
        <span class="c1"># Indices of negligible amplitude oscillators</span>
        <span class="n">negligible_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">thold</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># Remove negligible oscillators</span>
        <span class="nb">slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_slice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)),</span> <span class="n">osc_idx</span><span class="o">=</span><span class="n">negligible_idx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span>
        <span class="c1"># Update number of oscillators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">negligible_idx</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">OR</span><span class="si">}</span><span class="s1">Oscillations with negligible amplitude removed.&#39;</span>
                <span class="sa">f</span><span class="s1">&#39; </span><span class="se">\n</span><span class="s1">Updated number of oscillators: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="si">}{</span><span class="n">cols</span><span class="o">.</span><span class="n">END</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">NMR-EsPy  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">nmrespy.nlp.nlp</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Simon Hulse &amp; Mohammadali Foroozandeh.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.0.2.
    </div>
  </body>
</html>