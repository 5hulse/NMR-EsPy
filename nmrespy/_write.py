#!/usr/bin/python3
#io.py
# Simon Hulse
# simon.hulse@chem.ox.ac.uk

# DESCRIPION GOES HERE

import datetime
import os
import re
from shutil import copyfile
import subprocess

import matplotlib
import numpy as np
from numpy.fft import fft, fftshift
from scipy.integrate import simps
from scipy.linalg import norm

from nmrespy import *
from ._misc import *
from ._errors import *

def write_file(info, descrip, fname, dir, sf, sci_lims, format, force_overwrite):

    # unpack info needed to construct table contents
    res = info[0]
    dim = info[1]
    sfo = info[7]
    integrals = info[10]

    table = _constr_datatable(res, sfo, integrals, sf, sci_lims, dim)
    ts = _timestamp()
    path = _get_path(fname, dir, format, force_overwrite)

    # remove res and itegrals (now in table)
    info.pop(0)
    info.pop(9)

    if format == 'txt':
        _write_txt(info, table, path, descrip, ts)
    elif format == 'pdf':
        _write_pdf(info, table, path, descrip, ts)

    print(f'{G}Saved result to {path}{END}')



def _write_txt(info, table, path, descrip, timestamp):
    """
    Writes result of NMR-EsPy to a textfile.

    Parameters
    -----------
    info : list
        List of various parameters to be included in the preamble of the file.

    table : numpy.ndarray
        Array of contents to append to the result table. Generated
        by :py:meth:`_constr_datatable`.

    path : str
        Path to save textfile to.

    descrip : str or None
        A user-provided description of the result. If None, this is
        skipped.

    timestamp : str
        Time\date when :py:func:`write_file` is called. Generated by
        :py:func:`_timestamp`.
    """

    info = iter(info)

    datapath = next(info)
    sw_h = next(info)
    sw_p = next(info)
    off_h = next(info)
    off_p = next(info)
    sfo = next(info)
    bf = next(info)
    nuc = next(info)
    region_h = next(info)
    region_p = next(info)

    # write header
    msg = f'{timestamp}\n' # time and date
    if descrip:
        # user-provided description
        msg += f'{descrip}\n\nExperiment Information:\n'
    else:
        msg += '\nExperiment Information:\n'

    msg += f'data path:               {datapath}\n'

    if dim == 1:


        # unpack values from tuple
        sw_h, sw_p = sw_h[0], sw_p[0]
        off_h, off_p = off_h[0], off_p[0]
        sfo = sfo[0]
        bf = bf[0]
        msg += f'sweep width:             {sw_h:.4f}Hz ({sw_p:.4f}ppm)\n'
        msg += f'trans. frequency:        {sfo:.4f}MHz\n'
        msg += f'basic trans. frequency:  {bf:.4f}MHz\n'
        msg += f'trans. offset:           {off_h:.4f}Hz ({off_p:.4f}ppm)\n\n'


        msg += 'Region Considered:\n'
        if region_p and region_h:
            msg += f'{region_h[0][0]:.4f} - {region_h[0][1]:.4f}Hz'
            msg += f' ({region_p[0][0]:.4f} - {region_p[0][1]:.4f}ppm)\n\n'
        else:
            msg += f'full spectrum\n\n'

    elif dim == 2:
        msg += f'sweep width (F1):            {sw_h[0]:.4f}Hz ({sw_p[0]:.4f}ppm)\n'
        msg += f'sweep width (F2):            {sw_h[1]:.4f}Hz ({sw_p[1]:.4f}ppm)\n'
        msg += f'trans. frequency (F1):       {sfo[0]:.4f}MHz\n'
        msg += f'trans. frequency (F2):       {sfo[1]:.4f}MHz\n'
        msg += f'basic trans. frequency (F1): {bf[0]:.4f}MHz\n'
        msg += f'basic trans. frequency (F2): {bf[1]:.4f}MHz\n'
        msg += f'trans. offset (F1):          {off_h[0]:.4f}Hz ({off_p[0]:.4f}ppm)\n'
        msg += f'trans. offset (F2):          {off_h[1]:.4f}Hz ({off_p[1]:.4f}ppm)\n\n'


        msg += 'Region Considered:\n'
        if region_p and region_h:
            msg += f'F1: {region_h[0][0]:.4f} - {region_h[0][1]:.4f}Hz'
            msg += f' ({region_p[0][0]:.4f} - {region_p[0][1]:.4f}ppm)\n'
            msg += f'F2: {region_h[1][0]:.4f} - {region_h[1][1]:.4f}Hz'
            msg += f' ({region_p[1][0]:.4f} - {region_p[1][1]:.4f}ppm)\n\n'
        else:
            msg += f'full spectrum\n\n'


    # write table of parameters-
    # Determine width of each column (pads)
    cats = len(table[0]) # number of table categories
    pads = [1] * cats
    for entry in table:
        for i, e in enumerate(entry):
            pads[i] = len(e) + 1 if len(e) + 1 > pads[i] else pads[i]

    # table colunm headers
    if dim == 1:
        headers = ['#', 'amplitude', 'phase', 'frequency (Hz)',
                   'frequency (ppm)', 'damping factor', 'integrals',
                   'normalised integrals']
    elif dim == 2:
        headers = ['#', 'amplitude', 'phase', 'frequency 1 (Hz)',
                   'frequency 1 (ppm)', 'frequency 2 (Hz)',
                   'frequency 2 (ppm)', 'damping factor 1',
                   'damping factor 2', 'integrals', 'normalised integrals']

    # ensure the column paddings are not smaller than the header len + 1
    for i, header in enumerate(headers):
        pads[i] = len(header) + 1 if len(header) + 1 > pads[i] else pads[i]
        # construct column titles
        msg += '{:<{p}}│'.format(header, p=pads[i])
    msg = msg[:-1] + '\n' # rm final vertical bar and add newline

    # horizontal bar below headers
    for pad in pads:
        msg += '─' * pad + '┼'
    msg = msg[:-1] + '\n' # rm final cross bar and add newline

    # Appends contents to table
    for entry in table: # each row
        for i, e in enumerate(entry): # each element of the row
            msg += '{:<{p}}│'.format(e, p=pads[i])
        msg = msg[:-1] + '\n' # rm final vertical bar and add newline

    # blurb at bottom of file
    msg += '\nEstimation performed using NMR-EsPy\nAuthor: Simon Hulse ~ '
    msg += 'simon.hulse@chem.ox.ac.uk\nIf used in any publications, please'
    msg += ' cite:\n<Ref to paper>\nFor more information, visit our group'
    msg += ' website:\nhttp://foroozandeh.chem.ox.ac.uk/home\n'

    with open(path, 'w') as file:
        file.write(msg)


def _write_pdf(info, table, path, descrip, timestamp):
    """
    Writes result of NMR-EsPy to a pdf.

    Parameters
    -----------
    info : list
        List of various parameters to be included in the preamble of the file.

    table : numpy.ndarray
        Array of contents to append to the result table. Generated
        by :py:meth:`_constr_datatable`.

    path : str
        Path to save textfile to.

    descrip : str or None
        A user-provided description of the result. If None, this is
        skipped.

    timestamp : str
        Time\date when :py:func:`write_file` is called. Generated by
        :py:func:`_timestamp`.
    """

    info = iter(info)
    dim = next(info)

    if dim == 1:
        with open(os.path.join(NMRESPYPATH, 'config/latex_template_1d.txt'), 'r') as fh:
            txt = fh.read()

    txt = txt.replace('<MFLOGOPATH>', MFLOGOPATH)
    txt = txt.replace('<NMRESPYLOGOPATH>', NMRESPYLOGOPATH)
    txt = txt.replace('<TIMESTAMP>', timestamp.replace('\n', r'\\'))

    if descrip:
        txt = txt.replace('<DESCRIPTION>', descrip.replace('_', '\\_'))

    else:
        txt = txt.replace('\subsection*{Description}', '% \subsection*{Description}')
        txt = txt.replace('<DESCRIPTION>', '')

    datapath = next(info)
    txt = txt.replace('<DATAPATH>', datapath.replace('_', '\\_'))

    sw_h = next(info)
    sw_p = next(info)
    off_h = next(info)
    off_p = next(info)
    sfo = next(info)
    bf = next(info)
    nuc = next(info)

    for i, (sw_hz, sw_ppm, off_hz, off_ppm, sfo_, bf_, nuc_) in enumerate(zip(sw_h, sw_p, off_h, off_p, sfo, bf, nuc)):
        txt = txt.replace(f'<SW{i}_H>', f'{sw_hz:.4f}')
        txt = txt.replace(f'<SW{i}_P>', f'{sw_ppm:.4f}')
        txt = txt.replace(f'<OFF{i}_H>', f'{off_hz:.4f}')
        txt = txt.replace(f'<OFF{i}_P>', f'{off_ppm:.4f}')
        txt = txt.replace(f'<SFO{i}>', f'{sfo_:.4f}')
        txt = txt.replace(f'<BF{i}>', f'{bf_:.4f}')

        nucleus_comps = filter(None, re.split(r'(\d+)', nuc_))
        txt = txt.replace(f'<NUC{i}_MASS>', next(nucleus_comps))
        txt = txt.replace(f'<NUC{i}_ELEM>', next(nucleus_comps))

    region_h = next(info)
    region_p = next(info)

    if region_h:
        for i, (rh, rp) in enumerate(zip(region_h, region_p)):
            for j, (h, p) in enumerate(zip(rh, rp)):
                txt = txt.replace(f'<REGION{i}{j}_H>', f'{h:.4f}')
                txt = txt.replace(f'<REGION{i}{j}_P>', f'{p:.4f}')

    else:
        txt = txt.replace(r'$<REGION00_H>$ - $<REGION01_H>\si{\hertz}$\ ($<REGION00_P>$ - $<REGION01_P>$ppm)', 'full spectrum')

    fname = os.path.split(path)[1][:-4]

    try:
        figure = next(info)
        figure_path = fname + '_fig.pdf'
        figure.savefig(figure_path, dpi=600)
        txt = txt.replace('<FIGURE_PATH>', figure_path)


    except StopIteration:
        txt = txt.replace('\n% figure of result\n\\begin{center}\n  \\includegraphics[scale=1]{<FIGURE_PATH>}\n\\end{center}\n', '')


    table_str = ''

    # input table elements
    for row in table:
        for entry in row:
            table_str += f'$\\num{{{entry}}}$ & '
        table_str = table_str[:-2] + '\\\\\n    '
    table_str = table_str[:-5]
    txt = txt.replace('<TABLE>', table_str)

    # tmp paths: where tex file is compiled
    tmp_pdfpath = fname + '.pdf'
    tmp_texpath = fname + '.tex'

    # final paths: where tex file and pdf are finally saved to
    final_pdfpath = path
    final_texpath = path[:-3] + 'tex'

    with open(tmp_texpath, 'w') as fh:
        fh.write(txt)

    try:
        # -halt-on-error flag is vital. If any error arises in running
        # pdflatex, the program would get stuck
        run_latex = subprocess.run(
            ['pdflatex', '-halt-on-error', tmp_texpath],
            stdout=subprocess.DEVNULL,
            check=True
        )

        # rename pdf and tex files
        os.rename(tmp_texpath, final_texpath)
        os.rename(tmp_pdfpath, final_pdfpath)

        # print success message
        msg = f'{G}Result successfuly output to:\n' \
              + f'{final_pdfpath}\n' \
              + f'If you wish to customise the document, the TeX file can' \
              + f'be found at:\n' \
              + f'{final_texpath}{END}'
        print(msg)

    except subprocess.CalledProcessError:
        # pdflatex came across an error (or pdflatex doesn't exist)
        os.rename(tmp_texpath, final_texpath)
        raise LaTeXFailedError(final_texpath)

    # rename/remove files

    os.remove(tmp_texpath[:-4] + '.out')
    os.remove(tmp_texpath[:-4] + '.aux')
    os.remove(tmp_texpath[:-4] + '.log')

    # remove figure file if it exists
    try:
        os.remove(figure_path)
    except UnboundLocalError:
        pass



    # elif dim == 2:
    #     # convert sw and offset from Hz to ppm
    #     msg += r'Sweep Width (F1): & $\SI{' + f'{sw_h[0]:.4f}' + r'}{\hertz}$' \
    #            + r' ($' + f'{sw_p[0]:.4f}' + r'$ppm) \\' + '\n'
    #     msg += r'Sweep Width (F2): & $\SI{' + f'{sw_h[1]:.4f}' + r'}{\hertz}$' \
    #            + r' ($' + f'{sw_p[1]:.4f}' + r'$ppm) \\' + '\n'
    #     msg += r'Transmitter Frequency (F1): & $\SI{' + f'{sfo[0]:.4f}' \
    #            + r'}{\mega\hertz}$ \\' + '\n'
    #     msg += r'Transmitter Frequency (F2): & $\SI{' + f'{sfo[1]:.4f}' \
    #            + r'}{\mega\hertz}$ \\' + '\n'
    #     msg += r'Basic Transmitter frequency (F1): & $\SI{' + f'{bf[0]:.4f}' \
    #            + r'}{\mega\hertz}$ \\' + '\n'
    #     msg += r'Basic Transmitter frequency (F2): & $\SI{' + f'{bf[1]:.4f}' \
    #            + r'}{\mega\hertz}$ \\' + '\n'
    #     msg += r'Transmitter Offset (F1): & $\SI{' + f'{off_h[0]:.4f}' \
    #            + r'}{\hertz}$ ($' + f'{off_p[0]:.4f}' + r'$ppm) \\' + '\n'
    #     msg += r'Transmitter Offset (F2): & $\SI{' + f'{off_h[1]:.4f}' \
    #            + r'}{\hertz}$ ($' + f'{off_p[1]:.4f}' + r'$ppm) \\' + '\n'
    #
    #
    #     # spectral region analysed
    #     if region_h and region_p:
    #         msg += r'Spectral Region (F1): & $' + f' {region_h[0][0]:.4f}' \
    #                + r'$ - $' + f'{region_h[0][1]:.4f}' + r'\si{\hertz}$' \
    #                + r' ($' + f'{region_p[0][0]:.4f}' + r'$ - $' + \
    #                + f'{region_p[0][1]:.4f}' + r'$ppm) \\' + '\n'
    #         msg += r'Spectral Region (F2): & $' + f' {region_h[1][0]:.4f}' \
    #                + r'$ - $' + f'{region_h[1][1]:.4f}' + r'\si{\hertz}$' \
    #                + r' ($' + f'{region_p[1][0]:.4f}' + r'$ - $' + \
    #                + f'{region_p[1][1]:.4f}' + r'$ppm)' + '\n'
    #         msg += r'\end{tabular}' + '\n'
    #
    #     else:
    #         msg += r'Spectral Region: & full spectrum'
    #         msg += r'\end{tabular}' + '\n'
    #
    #     # table of oscillator parameters
    #     msg += r'\begin{longtable}[c]{c|cccccccccc}' + '\n'
    #     msg += r'\toprule' + '\n'
    #     msg += r'$m$ & $a_m$ & $\phi_m$ & $f_{1,m} (\si{\hertz})$' \
    #            + r' & $f_{1,m}$ (ppm) & $f_{2,m} (\si{\hertz})$' \
    #            + r' & $f_{2,m}$ (ppm) & $\eta_{1,m}$ & $\eta_{2,m}$' \
    #            + r' & $\int$ & normalised $\int$ \\' + '\n'
    #     msg += r'\midrule' + '\n'



def _constr_datatable(res, sfo, integrals, sf, sci_lims, dim):
    """
    Creates an array of values to input to results file table.

    Parameters
    -----------
    res : numpy.ndarray
        Parameter array, of shape (M, 4) or (M, 6).

    sfo : (float,) or (float, float)
        Transmitter offset frequency (MHz) in each dimension.

    integrals : list
        Oscillator integrals, of length M.

    sf : int
        Desired nuber of significant figures.

    dim : int
        Signal dimension (1 or 2).

    Returns
    --------
    table : list
        Values for result file table.
    """

    M = res.shape[0]

    table = []
    i_norm = norm(np.array(integrals)) # norm of integrals

    if dim == 1:
        for m in range(M):
            entry = []
            entry.append(f'{m+1}') # oscillator number
            entry.append(_strval(res[m, 0], sf, sci_lims)) # a
            entry.append(_strval(res[m, 1], sf, sci_lims)) # φ
            entry.append(_strval(res[m, 2], sf, sci_lims)) # f (Hz)
            entry.append(_strval(res[m, 2] / sfo[0], sf, sci_lims)) # f (ppm)
            entry.append(_strval(res[m, 3], sf, sci_lims)) # η
            entry.append(_strval(integrals[m], sf, sci_lims)) # integ
            entry.append(_strval(integrals[m] / i_norm, sf, sci_lims)) # integ / ‖integs‖
            table.append(entry)

    if dim == 2:
        for m in range(M):
            entry = []
            entry.append(f'{m+1}') # oscillator number
            entry.append(_strval(res[m, 0], sf, sci_lims)) # a
            entry.append(_strval(res[m, 1], sf, sci_lims)) # φ
            entry.append(_strval(res[m, 2], sf, sci_lims)) # f1 (Hz)
            entry.append(_strval(res[m, 2] / sfo[0], sf, sci_lims)) # f1 (ppm)
            entry.append(_strval(res[m, 3], sf, sci_lims)) # f2 (Hz)
            entry.append(_strval(res[m, 3] / sfo[1], sf, sci_lims)) # f2 (ppm)
            entry.append(_strval(res[m, 4], sf, sci_lims)) # η1
            entry.append(_strval(res[m, 5], sf, sci_lims)) # η2
            entry.append(_strval(integrals[m], sf, sci_lims)) # integ
            entry.append(_strval(integrals[m] / i_norm, sf, sci_lims)) # integ / ‖integs‖
            table.append(entry)

    return table


def _get_integrals(res, sw_h, off_h, n, dim):
    """
    Determine the integrals of peaks corressponding to each
    oscillator in a parameter array. Uses Simpson's rule
    to determine integrals. See ``scipy.integrate.simps`` [1]_

    Parameters
    -----------
    para : numpy.ndarray
        Parameter array, with ``para.shape = (M, 4)`` for 1D data, or
        ``para.shape = (M, 6)`` for 2D data.

    sw_h : (float,) or (float, float)
        Sweep width (Hz) in each dimension.

    off_h - (float,) or (float, float)
        Transmitter offset (Hz) in each dimension.

    n - (int,) or (int, int)
        Number of points to construct signals from.

    dim : int
        Signal dimension. Should be 1 or 2.

    Returns
    --------
    integs : numpy.ndarray
        Integral for each peak in the results, with ``integs.shape = (M,)``.

    References
    ----------
    .. [1] https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.simps.html
    """

    M = para.shape[0]
    integs = np.zeros(M)

    delta = ()
    for sw, n_ in zip(sw_h, n):
        delta += (sw / n_),

    for m, osc in enumerate(para):
        fid, _ = make_fid(osc, n, sw, offset, dim)
        spec = fftshift(fft(fid))
        if dim == 1:
            integs[m] = simps(np.absolute(np.real(spec)), dx=delta)
        elif dim == 2:
            integs[m] = simps(simps(np.absolute(np.real(spec)),
                                 dx=delta[1]), dx=delta[0])

    return integs


def _timestamp():
    """Constructs a string with time/date information."""
    now = datetime.datetime.now()
    d = now.strftime('%d') # day
    m = now.strftime('%m') # month
    y = now.strftime('%Y') # year
    t = now.strftime('%X') # time (hh:mm:ss)
    return f'{t}\n{d}-{m}-{y}'



def _get_path(fname, dir, fmt, force_overwrite):
    """_get_path(fname, dir, format, force_overwrite)

    Description
    -----------
    Generate the path to save textfile/pdf to

    Parameters
    ----------
    fname - str
        Name of file. Can have no extension, or '.txt'/'.pdf' extension.
    dir - str
        Name of directory to save the file to.
    fmt - str, either 'txt' or 'pdf'
        File format.
    force_overwrite - Bool
        Dictates whether or not to ask the user whether they are happy
        overwriting the file which possesses the desired path already
    """

    # 1) check last 4 digits are '.txt' or '.pdf'
    # 2) check '.' only accours once using split
    if fname[-4:] == f'.{fmt}' and len(fname.split('.')) == 2:
        pass
    elif '.' in fname:
        raise ValueError(f'{R}fname: {fname} - Unexpected file'
                             f' extension.{END}')
    else:
        fname += f'.{fmt}'
    return check_path(fname, dir, force_overwrite)


def _strval(value, sf, sci_lims):
    """_strval(value, sf, sci_lims)

    Description
    -----------
    Convert float to formatted string

    Parameters
    ----------
    value - float
        Value to convert.
    sf - int
        Number  of significant figures.
    sci_lims - tuple of two ints
        Specifies range of values to be formatted normmaly, and which
        to be formatted using scientific notation

    Returns
    -------
    strval - str
        Formatted value.
    """
    if sci_lims[0] >= 0 or sci_lims[1] <= 0:
        msg = f'\n{R}sci_lims[0] should by an int less than 0, and' \
              + f' sci_lims[1] should be an int greater than 0'
        raise ValueError(msg)

    # determine number of decimal points
    dp = sf - int(np.ceil(np.log10(np.absolute(value))))
    dp = 0 if dp < 0 else dp
    # round value
    val = round(value, dp)
    if val.is_integer():
        # if val of form 123456.0, convert to 123456
        val = int(val)
    if np.abs(val) >= 10 ** sci_lims[1] or np.abs(val) <= 10 ** sci_lims[0]:
        # convert to scientific notation
        return '{:.{s}e}'.format(val, s=sf-1).replace('e+0', 'E').replace('e-0', 'E-')
    return str(val)
