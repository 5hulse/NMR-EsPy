#!/usr/bin/python3
#io.py
# Simon Hulse
# simon.hulse@chem.ox.ac.uk

# DESCRIPION GOES HERE

import datetime
import os
from shutil import copyfile
import subprocess

import numpy as np
from numpy.fft import fft, fftshift
from scipy.integrate import simps
from scipy.linalg import norm

import nmrespy
from ._misc import *
from ._errors import *

def write_file(info, descrip, fname, dir, sf, sci_lims, format, force_overwrite):

    # unpack info needed to construct table contents
    res = info[0]
    dim = info[2]
    sfo = info[7]
    integrals = info[10]

    table = _constr_datatable(res, sfo, integrals, sf, sci_lims, dim)
    ts = _timestamp()
    path = _get_path(fname, dir, format, force_overwrite)

    if format == 'txt':
        _write_txt(info, table, path, descrip, ts)
    elif format == 'pdf':
        _write_pdf(info, table, path, descrip, ts)

    print(f'{G}Saved result to {path}{END}')



def _write_txt(info, table, path, descrip, timestamp):
    """
    Writes result of NMR-EsPy to a textfile.

    Parameters
    -----------
    info : list
        List of various parameters to be included in the preamble of the file.

    table : numpy.ndarray
        Array of contents to append to the result table. Generated
        by :py:meth:`_constr_datatable`.

    path : str
        Path to save textfile to.

    descrip : str or None
        A user-provided description of the result. If None, this is
        skipped.

    timestamp : str
        Time\date when :py:func:`write_file` is called. Generated by
        :py:func:`_timestamp`.
    """

    # unpack necessary info
    datapath = info[1]
    dim = info[2]
    sw_h = info[3]
    sw_p = info[4]
    off_h = info[5]
    off_p = info[6]
    sfo = info[7]
    bf = info[8]
    nuc = info[9]
    region_h = info[11]
    region_p = info[12]

    # ---write header--------------------------
    # start of file text contents (msg)
    msg = f'{timestamp}\n' # time and date
    if descrip:
        # user-provided description
        msg += f'{descrip}\n\nExperiment Information:\n'
    else:
        msg += '\nExperiment Information:\n'

    if dim == 1:
        msg += f'data path:               {datapath}\n'

        # unpack values from tuple
        sw_h, sw_p = sw_h[0], sw_p[0]
        off_h, off_p = off_h[0], off_p[0]
        sfo = sfo[0]
        bf = bf[0]
        msg += f'sweep width:             {sw_h:.4f}Hz ({sw_p:.4f}ppm)\n'
        msg += f'trans. frequency:        {sfo:.4f}MHz\n'
        msg += f'basic trans. frequency:  {bf:.4f}MHz\n'
        msg += f'trans. offset:           {off_h:.4f}Hz ({off_p:.4f}ppm)\n\n'


        msg += 'Region Considered:\n'
        if region_p and region_h:
            msg += f'{region_h[0][0]:.4f} - {region_h[0][1]:.4f}Hz'
            msg += f' ({region_p[0][0]:.4f} - {region_p[0][1]:.4f}ppm)\n\n'
        else:
            msg += f'full spectrum\n\n'

    elif dim == 2:
        msg += f'data path:                   {datapath}\n'
        msg += f'sweep width (F1):            {sw_h[0]:.4f}Hz ({sw_p[0]:.4f}ppm)\n'
        msg += f'sweep width (F2):            {sw_h[1]:.4f}Hz ({sw_p[1]:.4f}ppm)\n'
        msg += f'trans. frequency (F1):       {sfo[0]:.4f}MHz\n'
        msg += f'trans. frequency (F2):       {sfo[1]:.4f}MHz\n'
        msg += f'basic trans. frequency (F1): {bf[0]:.4f}MHz\n'
        msg += f'basic trans. frequency (F2): {bf[1]:.4f}MHz\n'
        msg += f'trans. offset (F1):          {off_h[0]:.4f}Hz ({off_p[0]:.4f}ppm)\n'
        msg += f'trans. offset (F2):          {off_h[1]:.4f}Hz ({off_p[1]:.4f}ppm)\n\n'


        msg += 'Region Considered:\n'
        if region_p and region_h:
            msg += f'F1: {region_h[0][0]:.4f} - {region_h[0][1]:.4f}Hz'
            msg += f' ({region_p[0][0]:.4f} - {region_p[0][1]:.4f}ppm)\n'
            msg += f'F2: {region_h[1][0]:.4f} - {region_h[1][1]:.4f}Hz'
            msg += f' ({region_p[1][0]:.4f} - {region_p[1][1]:.4f}ppm)\n\n'
        else:
            msg += f'full spectrum\n\n'


    # write table of parameters-
    # Determine width of each column (pads)
    cats = len(table[0]) # number of table categories
    pads = [1] * cats
    for entry in table:
        for i, e in enumerate(entry):
            pads[i] = len(e) + 1 if len(e) + 1 > pads[i] else pads[i]

    # table colunm headers
    if dim == 1:
        headers = ['#', 'amplitude', 'phase', 'frequency (Hz)',
                   'frequency (ppm)', 'damping factor', 'integrals',
                   'normalised integrals']
    elif dim == 2:
        headers = ['#', 'amplitude', 'phase', 'frequency 1 (Hz)',
                   'frequency 1 (ppm)', 'frequency 2 (Hz)',
                   'frequency 2 (ppm)', 'damping factor 1',
                   'damping factor 2', 'integrals', 'normalised integrals']

    # ensure the column paddings are not smaller than the header len + 1
    for i, header in enumerate(headers):
        pads[i] = len(header) + 1 if len(header) + 1 > pads[i] else pads[i]
        # construct column titles
        msg += '{:<{p}}│'.format(header, p=pads[i])
    msg = msg[:-1] + '\n' # rm final vertical bar and add newline

    # horizontal bar below headers
    for pad in pads:
        msg += '─' * pad + '┼'
    msg = msg[:-1] + '\n' # rm final cross bar and add newline

    # Appends contents to table
    for entry in table: # each row
        for i, e in enumerate(entry): # each element of the row
            msg += '{:<{p}}│'.format(e, p=pads[i])
        msg = msg[:-1] + '\n' # rm final vertical bar and add newline

    # blurb at bottom of file
    msg += '\nEstimation performed using NMR-EsPy\nAuthor: Simon Hulse ~ '
    msg += 'simon.hulse@chem.ox.ac.uk\nIf used in any publications, please'
    msg += ' cite:\n<Ref to paper>\nFor more information, visit our group'
    msg += ' website:\nhttp://foroozandeh.chem.ox.ac.uk/home\n'

    with open(path, 'w') as file:
        file.write(msg)


def _write_pdf(info, table, path, descrip, timestamp):
    """
    Writes result of NMR-EsPy to a pdf.

    Parameters
    -----------
    info : list
        List of various parameters to be included in the preamble of the file.

    table : numpy.ndarray
        Array of contents to append to the result table. Generated
        by :py:meth:`_constr_datatable`.

    path : str
        Path to save textfile to.

    descrip : str or None
        A user-provided description of the result. If None, this is
        skipped.

    timestamp : str
        Time\date when :py:func:`write_file` is called. Generated by
        :py:func:`_timestamp`.
    """

    # unpack necessary info
    datapath = info[1]
    dim = info[2]
    sw_h = info[3]
    sw_p = info[4]
    off_h = info[5]
    off_p = info[6]
    sfo = info[7]
    bf = info[8]
    nuc = info[9]
    region_h = info[11]
    region_p = info[12]

    # paths to documentation, and images used in pdf
    espypath = os.path.dirname(nmrespy.__file__)
    mflogopath = os.path.join(espypath, 'pics/mf_group_logo.pdf')
    logopath = os.path.join(espypath, 'pics/nmrespy_full.png')

    # Preamble
    msg = r'\documentclass[8pt]{article}' + '\n'
    if dim == 1:
        msg += r'\usepackage[a4paper,margin=1in]{geometry}' + '\n'
    elif dim == 1:
        msg += r'\usepackage[a4paper,landscape,margin=1in]{geometry}' + '\n'
    msg += r'\usepackage{cmbright}' + '\n'
    msg += r'\usepackage{amsmath}' + '\n'
    msg += r'\usepackage{booktabs}' + '\n'
    msg += r'\usepackage{enumitem}' + '\n'
    msg += r'\usepackage{graphicx}' + '\n'
    msg += r'\usepackage[hidelinks]{hyperref}' + '\n'
    msg += r'\usepackage{longtable}' + '\n'
    msg += r'\usepackage{siunitx}' + '\n'
    msg += r'\usepackage{xcolor}[dvipsnames]'
    msg += r'\setlength\parindent{0pt}' + '\n'

    # Header
    msg += r'\begin{document}' + '\n'
    msg += r'\begin{figure}[!ht]' + '\n'
    # MF group logo
    msg += r'\begin{minipage}[b][2.5cm][c]{.72\textwidth}' + '\n'
    msg += r'\href{http://foroozandeh.chem.ox.ac.uk/home}' \
           + r'{\includegraphics[scale=0.35]{' \
           + f'{mflogopath}' \
           + r'}}' + '\n'
    msg += r'\end{minipage}' + '\n'
    # NMR-EsPy logo
    msg += r'\begin{minipage}[b][2.5cm][c]{.27\textwidth}' + '\n'
    msg += r'\href{https://github.com/foroozandehgroup/NMR-EsPy}' \
           + r'{\includegraphics[scale=0.1]{' \
           + f'{logopath}' \
           + r'}}' + '\n'
    msg += r'\end{minipage}' + '\n'
    msg += r'\end{figure}' + '\n'

    msg += r'\texttt{' + timestamp + r'}' + '\n'
    # user-provided description
    if descrip:
        msg += r'\subsection*{Description}' + '\n'
        msg += f'{descrip}' + '\n'

    # experiment parameters
    msg += r'\subsection*{Experiment Information}' + '\n'
    msg += r'\hspace{-6pt}'
    msg += r'\begin{tabular}{ll}' + '\n'
    # path data was imported from
    datapath = datapath.replace('_', r'\_')
    msg += r'Data path: & \texttt{' + f'{datapath}' + r'} \\' + '\n'

    if dim == 1:
        # convert sw and offset from Hz to ppm
        sw_h, sw_p = sw_h[0], sw_p[0]
        off_h, off_p = off_h[0], off_p[0]
        sfo = sfo[0]
        bf = bf[0]

        msg += r'Sweep Width: & $\SI{' + f'{sw_h:.4f}' + r'}{\hertz}$' \
               + r' ($' + f'{sw_p:.4f}' + r'$ppm) \\' + '\n'
        msg += r'Transmitter Frequency: & $\SI{' + f'{sfo:.4f}' \
               + r'}{\mega\hertz}$ \\' + '\n'
        msg += r'Basic Transmitter Frequency: & $\SI{' + f'{bf:.4f}' \
               + r'}{\mega\hertz}$ \\' + '\n'
        msg += r'Transmitter Offset: & $\SI{' + f'{off_h:.4f}' + r'}{\hertz}$' \
               + r' ($' + f'{off_p:.4f}' + r'$ppm) \\' + '\n'

        if region_h and region_p:
            msg += r'Spectral Region: & $' + f' {region_h[0][0]:.4f}' \
                   + r'$ - $' + f'{region_h[0][1]:.4f}' + r'\si{\hertz}$' \
                   + r' ($' + f'{region_p[0][0]:.4f}' + r'$ - $' \
                   + f'{region_p[0][1]:.4f}' + r'$ppm)' + '\n'
            msg += r'\end{tabular}' + '\n'

        else:
            msg += r'Spectral Region: & full spectrum'
            msg += r'\end{tabular}' + '\n'

        # table of oscillator parameters
        msg += r'\subsection*{Result}' + '\n'
        msg += r'\begin{longtable}[c]{c|ccccccc}' + '\n'
        msg += r'\toprule' + '\n'
        msg += r'$m$ & $a_m$ & $\phi_m$ & $f_m (\si{\hertz})$ & $f_m$ (ppm)' \
               + r' & $\eta_m$ & $\int$ & normalised $\int$ \\' + '\n'
        msg += r'\midrule' + '\n'

    elif dim == 2:
        # convert sw and offset from Hz to ppm
        msg += r'Sweep Width (F1): & $\SI{' + f'{sw_h[0]:.4f}' + r'}{\hertz}$' \
               + r' ($' + f'{sw_p[0]:.4f}' + r'$ppm) \\' + '\n'
        msg += r'Sweep Width (F2): & $\SI{' + f'{sw_h[1]:.4f}' + r'}{\hertz}$' \
               + r' ($' + f'{sw_p[1]:.4f}' + r'$ppm) \\' + '\n'
        msg += r'Transmitter Frequency (F1): & $\SI{' + f'{sfo[0]:.4f}' \
               + r'}{\mega\hertz}$ \\' + '\n'
        msg += r'Transmitter Frequency (F2): & $\SI{' + f'{sfo[1]:.4f}' \
               + r'}{\mega\hertz}$ \\' + '\n'
        msg += r'Basic Transmitter frequency (F1): & $\SI{' + f'{bf[0]:.4f}' \
               + r'}{\mega\hertz}$ \\' + '\n'
        msg += r'Basic Transmitter frequency (F2): & $\SI{' + f'{bf[1]:.4f}' \
               + r'}{\mega\hertz}$ \\' + '\n'
        msg += r'Transmitter Offset (F1): & $\SI{' + f'{off_h[0]:.4f}' \
               + r'}{\hertz}$ ($' + f'{off_p[0]:.4f}' + r'$ppm) \\' + '\n'
        msg += r'Transmitter Offset (F2): & $\SI{' + f'{off_h[1]:.4f}' \
               + r'}{\hertz}$ ($' + f'{off_p[1]:.4f}' + r'$ppm) \\' + '\n'


        # spectral region analysed
        if region_h and region_p:
            msg += r'Spectral Region (F1): & $' + f' {region_h[0][0]:.4f}' \
                   + r'$ - $' + f'{region_h[0][1]:.4f}' + r'\si{\hertz}$' \
                   + r' ($' + f'{region_p[0][0]:.4f}' + r'$ - $' + \
                   + f'{region_p[0][1]:.4f}' + r'$ppm) \\' + '\n'
            msg += r'Spectral Region (F2): & $' + f' {region_h[1][0]:.4f}' \
                   + r'$ - $' + f'{region_h[1][1]:.4f}' + r'\si{\hertz}$' \
                   + r' ($' + f'{region_p[1][0]:.4f}' + r'$ - $' + \
                   + f'{region_p[1][1]:.4f}' + r'$ppm)' + '\n'
            msg += r'\end{tabular}' + '\n'

        else:
            msg += r'Spectral Region: & full spectrum'
            msg += r'\end{tabular}' + '\n'

        # table of oscillator parameters
        msg += r'\begin{longtable}[c]{c|cccccccccc}' + '\n'
        msg += r'\toprule' + '\n'
        msg += r'$m$ & $a_m$ & $\phi_m$ & $f_{1,m} (\si{\hertz})$' \
               + r' & $f_{1,m}$ (ppm) & $f_{2,m} (\si{\hertz})$' \
               + r' & $f_{2,m}$ (ppm) & $\eta_{1,m}$ & $\eta_{2,m}$' \
               + r' & $\int$ & normalised $\int$ \\' + '\n'
        msg += r'\midrule' + '\n'

    # input table elements
    for entry in table:
        for e in entry:
            msg += r' $\num{' + e + r'}$ &'
        msg = msg[:-1] + r'\\' + '\n'
    msg += r'\bottomrule' + '\n'
    msg += r'\end{longtable}' + '\n'

    # blurb
    msg += r'\small' + '\n'
    msg += r'\fbox{'
    msg += r'\begin{minipage}{.5\textwidth}'
    msg += r'Estimation perfomred using NMR-EsPy.\\' + '\n'
    msg += r'Author: Simon Hulse\\' + '\n'
    msg += r'For more information, see the \href{' \
           + r'http://foroozandeh.chem.ox.ac.uk/home' \
           + r'}{\textcolor{blue}{documentation}}, or email:' \
           + r' \href{mailto:simon.hulse@chem.ox.ac.uk}'\
           + r'{\texttt{simon.hulse@chem.ox.ac.uk}}\\' + '\n' \
           + r'If used in a publication, please cite:\\' + '\n' \
           + r'\textbf{Inc. Reference Here}' + '\n'
    msg += r'\end{minipage}' + '\n'
    msg += r'}' + '\n'
    msg += r'\end{document}'

    # tmp paths: paths where tex file is compiled, and where pdf originally
    # saved (cwd)
    tmp_texpath = os.path.split(path)[1][:-3] + 'tex'
    tmp_pdfpath = tmp_texpath[:-3] + 'pdf'
    # final paths@ paths where tex file and pdf are finally saved to
    final_texpath = path[:-3] + 'tex'
    final_pdfpath = path[:-3] + 'pdf'

    with open(tmp_texpath, 'w') as f:
        f.write(msg)

    try:
        # -halt-on-error flag is vital. If any error arises in running
        # pdflatex, the program would just get stuck
        run_latex = subprocess.run([
            'pdflatex',
            '-halt-on-error',
            f'{tmp_texpath}'],
            stdout=subprocess.DEVNULL,
            check=True)

        os.remove(tmp_texpath[:-3] + 'out')
        os.remove(tmp_texpath[:-3] + 'aux')
        os.remove(tmp_texpath[:-3] + 'log')
        os.rename(tmp_texpath, final_texpath)
        os.rename(tmp_pdfpath, final_pdfpath)

        msg = f'{G}Result successfuly output to:\n' \
              + f'{final_pdfpath}\n' \
              + f'If you wish to customise the document, the LaTeX file can' \
              + f'be found at:\n' \
              + f'{final_texpath}{END}'
        print(msg)

    except subprocess.CalledProcessError:
        try:
            os.remove(tmp_texpath[:-3] + 'out')
            os.remove(tmp_texpath[:-3] + 'aux')
            os.remove(tmp_texpath[:-3] + 'log')
        except:
            pass

        os.rename(tmp_texpath, final_texpath)
        raise LaTeXFailedError(final_texpath)


def _constr_datatable(res, sfo, integrals, sf, sci_lims, dim):
    """
    Creates an array of values to input to results file table.

    Parameters
    -----------
    res : numpy.ndarray
        Parameter array, of shape (M, 4) or (M, 6).

    sfo : (float,) or (float, float)
        Transmitter offset frequency (MHz) in each dimension.

    integrals : list
        Oscillator integrals, of length M.

    sf : int
        Desired nuber of significant figures.

    dim : int
        Signal dimension (1 or 2).

    Returns
    --------
    table : list
        Values for result file table.
    """

    M = res.shape[0]

    table = []
    i_norm = norm(np.array(integrals)) # norm of integrals

    if dim == 1:
        for m in range(M):
            entry = []
            entry.append(f'{m+1}') # oscillator number
            entry.append(_strval(res[m, 0], sf, sci_lims)) # a
            entry.append(_strval(res[m, 1], sf, sci_lims)) # φ
            entry.append(_strval(res[m, 2], sf, sci_lims)) # f (Hz)
            entry.append(_strval(res[m, 2] / sfo[0], sf, sci_lims)) # f (ppm)
            entry.append(_strval(res[m, 3], sf, sci_lims)) # η
            entry.append(_strval(integrals[m], sf, sci_lims)) # integ
            entry.append(_strval(integrals[m] / i_norm, sf, sci_lims)) # integ / ‖integs‖
            table.append(entry)

    if dim == 2:
        for m in range(M):
            entry = []
            entry.append(f'{m+1}') # oscillator number
            entry.append(_strval(res[m, 0], sf, sci_lims)) # a
            entry.append(_strval(res[m, 1], sf, sci_lims)) # φ
            entry.append(_strval(res[m, 2], sf, sci_lims)) # f1 (Hz)
            entry.append(_strval(res[m, 2] / sfo[0], sf, sci_lims)) # f1 (ppm)
            entry.append(_strval(res[m, 3], sf, sci_lims)) # f2 (Hz)
            entry.append(_strval(res[m, 3] / sfo[1], sf, sci_lims)) # f2 (ppm)
            entry.append(_strval(res[m, 4], sf, sci_lims)) # η1
            entry.append(_strval(res[m, 5], sf, sci_lims)) # η2
            entry.append(_strval(integrals[m], sf, sci_lims)) # integ
            entry.append(_strval(integrals[m] / i_norm, sf, sci_lims)) # integ / ‖integs‖
            table.append(entry)

    return table


def _get_integrals(res, sw_h, off_h, n, dim):
    """
    Determine the integrals of peaks corressponding to each
    oscillator in a parameter array. Uses Simpson's rule
    to determine integrals. See ``scipy.integrate.simps`` [1]_

    Parameters
    -----------
    para : numpy.ndarray
        Parameter array, with ``para.shape = (M, 4)`` for 1D data, or
        ``para.shape = (M, 6)`` for 2D data.

    sw_h : (float,) or (float, float)
        Sweep width (Hz) in each dimension.

    off_h - (float,) or (float, float)
        Transmitter offset (Hz) in each dimension.

    n - (int,) or (int, int)
        Number of points to construct signals from.

    dim : int
        Signal dimension. Should be 1 or 2.

    Returns
    --------
    integs : numpy.ndarray
        Integral for each peak in the results, with ``integs.shape = (M,)``.

    References
    ----------
    .. [1] https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.simps.html
    """

    M = para.shape[0]
    integs = np.zeros(M)

    delta = ()
    for sw, n_ in zip(sw_h, n):
        delta += (sw / n_),

    for m, osc in enumerate(para):
        fid, _ = make_fid(osc, n, sw, offset, dim)
        spec = fftshift(fft(fid))
        if dim == 1:
            integs[m] = simps(np.absolute(np.real(spec)), dx=delta)
        elif dim == 2:
            integs[m] = simps(simps(np.absolute(np.real(spec)),
                                 dx=delta[1]), dx=delta[0])

    return integs


def _timestamp():
    """Constructs a string with time/date information."""
    now = datetime.datetime.now()
    d = now.strftime('%d') # day
    m = now.strftime('%m') # month
    y = now.strftime('%Y') # year
    t = now.strftime('%X') # time (hh:mm:ss)
    return f'{t}\n{d}-{m}-{y}'



def _get_path(fname, dir, fmt, force_overwrite):
    """_get_path(fname, dir, format, force_overwrite)

    Description
    -----------
    Generate the path to save textfile/pdf to

    Parameters
    ----------
    fname - str
        Name of file. Can have no extension, or '.txt'/'.pdf' extension.
    dir - str
        Name of directory to save the file to.
    fmt - str, either 'txt' or 'pdf'
        File format.
    force_overwrite - Bool
        Dictates whether or not to ask the user whether they are happy
        overwriting the file which possesses the desired path already
    """

    # 1) check last 4 digits are '.txt' or '.pdf'
    # 2) check '.' only accours once using split
    if fname[-4:] == f'.{fmt}' and len(fname.split('.')) == 2:
        pass
    elif '.' in fname:
        raise ValueError(f'{R}fname: {fname} - Unexpected file'
                             f' extension.{END}')
    else:
        fname += f'.{fmt}'
    return check_path(fname, dir, force_overwrite)


def _strval(value, sf, sci_lims):
    """_strval(value, sf, sci_lims)

    Description
    -----------
    Convert float to formatted string

    Parameters
    ----------
    value - float
        Value to convert.
    sf - int
        Number  of significant figures.
    sci_lims - tuple of two ints
        Specifies range of values to be formatted normmaly, and which
        to be formatted using scientific notation

    Returns
    -------
    strval - str
        Formatted value.
    """
    if sci_lims[0] >= 0 or sci_lims[1] <= 0:
        msg = f'\n{R}sci_lims[0] should by an int less than 0, and' \
              + f' sci_lims[1] should be an int greater than 0'
        raise ValueError(msg)

    # determine number of decimal points
    dp = sf - int(np.ceil(np.log10(np.absolute(value))))
    dp = 0 if dp < 0 else dp
    # round value
    val = round(value, dp)
    if val.is_integer():
        # if val of form 123456.0, convert to 123456
        val = int(val)
    if np.abs(val) >= 10 ** sci_lims[1] or np.abs(val) <= 10 ** sci_lims[0]:
        # convert to scientific notation
        return '{:.{s}e}'.format(val, s=sf-1).replace('e+0', 'E').replace('e-0', 'E-')
    return str(val)
